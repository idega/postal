<?xml version="1.0" encoding="UTF-8" ?>
<beans
	xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:oauth="http://www.springframework.org/schema/security/oauth2"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:security="http://www.springframework.org/schema/security"
	xmlns:mvc="http://www.springframework.org/schema/mvc"
	xsi:schemaLocation="http://www.springframework.org/schema/security/oauth2 http://www.springframework.org/schema/security/spring-security-oauth2-2.0.xsd  
  		http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd  
  		http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-3.2.xsd   
  		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd  
  		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.1.xsd ">

	<!-- Initial data source configuration -->
	<bean
		id="oauthDataSource"
		class="com.idega.block.oauth2.server.factory.IdegaJndiObjectFactoryBean">
		<property
			name="jndiName"
			value="java:comp/env/jdbc/DefaultDS" />
		<property
			name="lookupOnStartup"
			value="false" />
		<property
			name="cache"
			value="true" />
		<property
			name="proxyInterface"
			value="javax.sql.DataSource" />
	</bean>

	<!-- 
	<bean
		id="oauth2Service"
		class="com.idega.block.oauth2.server.business.impl.OAuth2ServiceImpl" >
	</bean> 
	-->

	<bean
		id="keyGenerator"
		class="com.idega.block.oauth2.server.configuration.IdegaAuthenticationKeyGenerator" >
	</bean>

	<!-- This defined token store, we have used inmemory tokenstore for now 
		but this can be changed to a user defined one -->
	<bean
		id="tokenStore"
		class="com.idega.block.oauth2.server.configuration.IdegaJDBCTokenStore" >
		<constructor-arg ref="oauthDataSource" />
		<property
			name="authenticationKeyGenerator"
			ref="keyGenerator" />
	</bean>

	<!--
		Protecting the token endpoint
	-->

	<bean
		id="clientDetails"
		class="org.springframework.security.oauth2.provider.client.JdbcClientDetailsService">
		<constructor-arg ref="oauthDataSource" />
	</bean>

	<!-- 
		Next we configure the authentication manager and client details service 
	-->
	<bean
		id="clientDetailsUserService"
		class="com.idega.block.oauth2.server.configuration.IdegaUserDetailsService">
		<constructor-arg ref="clientDetails" />
	</bean>
	<security:authentication-manager
		id="clientAuthenticationManager">
		<security:authentication-provider user-service-ref="clientDetailsUserService" />
	</security:authentication-manager>
	<bean
		id="clientCredentialsTokenEndpointFilter"
		class="org.springframework.security.oauth2.provider.client.ClientCredentialsTokenEndpointFilter">
		<property
			name="authenticationManager"
			ref="clientAuthenticationManager" />
	</bean>

	<!--  -->
	<bean
		id="clientAuthenticationEntryPoint"
		class="org.springframework.security.oauth2.provider.error.OAuth2AuthenticationEntryPoint">
		<property
			name="realmName"
			value="test/client" />
		<property
			name="typeName"
			value="Basic" />
	</bean>

	<!--  -->
	<bean
		id="oauthAccessDeniedHandler"
		class="org.springframework.security.oauth2.provider.error.OAuth2AccessDeniedHandler" />

	<!-- 
		This is default url to get a token from OAuth. 
		It is a good idea to protect access to token requests to only those 
		client applications that you know about. Using Spring security we can 
		set up basic authentication on calls to the token endpoint 
	-->
	<security:http
		pattern="/authentication/oauth/token"
		create-session="stateless"
		authentication-manager-ref="clientAuthenticationManager">
		<security:anonymous enabled="false" />
		<security:http-basic entry-point-ref="clientAuthenticationEntryPoint" />
		<security:access-denied-handler ref="oauthAccessDeniedHandler" />
		
		<security:intercept-url
			pattern="/authentication/oauth/token"
			access="IS_AUTHENTICATED_FULLY" />
		<!-- include this only if you need to authenticate clients via request 
			parameters -->
		<security:custom-filter
			ref="clientCredentialsTokenEndpointFilter"
			after="BASIC_AUTH_FILTER" />
	</security:http>

	<!--
		Configuring Token Services
	-->

	<bean 
		id="idegaTokenEnhancer"
		class="com.idega.block.oauth2.server.configuration.IdegaTokenEnhancer">
	</bean>

	<!--
		The final piece of configuration is to manage storage and retrieval of 
		access tokens.
		This is where we defined token based configurations, token validity 
		and other things. -->
	<bean
		id="tokenServices"
		class="com.idega.block.oauth2.server.configuration.IdegaDefaultTokenServices">
		<property
			name="tokenStore"
			ref="tokenStore" />
		<property
			name="supportRefreshToken"
			value="true" />
		<property
			name="accessTokenValiditySeconds"
			value="86400" />
		<property
			name="clientDetailsService"
			ref="clientDetails" />
		<property
			name="tokenEnhancer"
			ref="idegaTokenEnhancer"/>
	</bean>

	<!--
		Configuring OAuth flows to support. 
		The default token endpoint is /oauth/token 
	-->

	<!-- 
		A user approval handler that remembers approval decisions by consulting 
		existing tokens 
	-->
	<bean id="oAuth2RequestFactory"
	    class="org.springframework.security.oauth2.provider.request.DefaultOAuth2RequestFactory">
	    <constructor-arg ref="clientDetails" />
	</bean>

	<!--  -->
	<bean
		id="userApprovalHandler"
		class="org.springframework.security.oauth2.provider.approval.TokenStoreUserApprovalHandler">
		<property
			name="tokenStore"
			ref="tokenStore" />
		<property
			name="requestFactory"
			ref="oAuth2RequestFactory" />
	</bean>
	
	<!-- Custom refresh token handler -->
	<bean
		id="idegaRefreshTokenGranter"
		class="com.idega.block.oauth2.server.provider.refresh.IdegaRefreshTokenGranter">
		<constructor-arg ref="tokenServices"/>
		<constructor-arg ref="clientDetails"/>
		<constructor-arg ref="oAuth2RequestFactory"/>
	</bean>

	<oauth:authorization-server
		client-details-service-ref="clientDetails"
		token-services-ref="tokenServices"
		user-approval-handler-ref="userApprovalHandler">
		<oauth:authorization-code />
		<oauth:implicit />
		<oauth:client-credentials />
		<oauth:password />
		<oauth:custom-grant token-granter-ref="idegaRefreshTokenGranter"/>
	</oauth:authorization-server>

	<!--
		Protecting access to resources
	-->

	<!-- 
		We need to configure a spring resource server filter. This will check 
		that there is a valid access token in the request header. 
	-->
	<oauth:resource-server
		id="resourceServerFilter"
		resource-id="test"
		token-services-ref="tokenServices" />

	<!--  -->
	<bean
		id="oauthAuthenticationEntryPoint"
		class="org.springframework.security.oauth2.provider.error.OAuth2AuthenticationEntryPoint">
		<property
			name="realmName"
			value="test" />
	</bean>

	<!-- 
		Configure an access manager that uses these voters 
	-->
	<bean
		id="accessDecisionManager"
		class="org.springframework.security.access.vote.UnanimousBased"
		xmlns="http://www.springframework.org/schema/beans">
		<constructor-arg>
			<list>
				<bean class="org.springframework.security.oauth2.provider.vote.ScopeVoter" />
				<bean class="org.springframework.security.access.vote.RoleVoter" />
				<bean class="org.springframework.security.access.vote.AuthenticatedVoter" />
			</list>
		</constructor-arg>
	</bean>

	<security:http pattern="/company/**" security="none" auto-config="true"/>
	<security:http pattern="/api/afterschoolcare/**" security="none" auto-config="true"/>
	<security:http pattern="/api/openservices/**" security="none" auto-config="true"/>
	<security:http pattern="/rest/leaderboard/**" security="none" auto-config="true"/>
	<security:http pattern="/api/leaderboard/**" security="none" auto-config="true"/>
	<security:http pattern="/rest/golferSearch/**" security="none" auto-config="true"/>
	<security:http pattern="/api/golferSearch/**" security="none" auto-config="true"/>
	<security:http pattern="/rest/tournamentList/**" security="none" auto-config="true"/>
	<security:http pattern="/api/tournamentList/**" security="none" auto-config="true"/>
	<security:http pattern="/rest/tournamentTourList/**" security="none" auto-config="true"/>
	<security:http pattern="/api/tournamentTourList/**" security="none" auto-config="true"/>
	<security:http pattern="/rest/areas/**" security="none" auto-config="true"/>
	<security:http pattern="/api/areas/**" security="none" auto-config="true"/>
	<security:http pattern="/rest/clubs/**" security="none" auto-config="true"/>
	<security:http pattern="/api/clubs/**" security="none" auto-config="true"/>
	<security:http pattern="/rest/clubNews/**" security="none" auto-config="true"/>
	<security:http pattern="/api/clubNews/**" security="none" auto-config="true"/>
	<security:http pattern="/api/tournamentResult/**" security="none" auto-config="true"/>
	<security:http pattern="/api/tournament/**" security="none" auto-config="true"/>
	<security:http pattern="/rest/member/**" security="none" auto-config="true"/>
	<security:http pattern="/rest/teeTimeBooking/**" security="none" auto-config="true"/>
	<security:http pattern="/api/teeTimeBooking/**" security="none" auto-config="true"/>
	<security:http pattern="/rest/teeTimeGolfers/**" security="none" auto-config="true"/>
	<security:http pattern="/api/teeTimeGolfers/**" security="none" auto-config="true"/>
	<security:http pattern="/api/logout/**" security="none" auto-config="true"/>

	<!-- This is where we tells spring security what URL should be protected and which roles have access to them -->
	<security:http
		pattern="/api/**"
		create-session="never"
		entry-point-ref="oauthAuthenticationEntryPoint"
		access-decision-manager-ref="accessDecisionManager"
		xmlns="http://www.springframework.org/schema/security">
		<security:anonymous enabled="false" />
		<security:intercept-url
			pattern="/api/**"
			access="ROLE_APP" />
		<security:custom-filter
			ref="resourceServerFilter"
			before="PRE_AUTH_FILTER" />
		<security:access-denied-handler ref="oauthAccessDeniedHandler" />
	</security:http>
    <security:http
		pattern="/rest/**"
		create-session="never"
		entry-point-ref="oauthAuthenticationEntryPoint"
		access-decision-manager-ref="accessDecisionManager"
		xmlns="http://www.springframework.org/schema/security">
		<security:anonymous enabled="false" />
		<security:intercept-url
			pattern="/rest/**"
			access="ROLE_APP" />
		<security:custom-filter
			ref="resourceServerFilter"
			before="PRE_AUTH_FILTER" />
		<security:access-denied-handler ref="oauthAccessDeniedHandler" />
	</security:http>
	<security:http
		pattern="/central/**"
		create-session="never"
		entry-point-ref="oauthAuthenticationEntryPoint"
		access-decision-manager-ref="accessDecisionManager"
		xmlns="http://www.springframework.org/schema/security">
		<security:anonymous enabled="false" />
		<security:intercept-url
			pattern="/central/**"
			access="ROLE_APP" />
		<security:custom-filter
			ref="resourceServerFilter"
			before="PRE_AUTH_FILTER" />
		<security:access-denied-handler ref="oauthAccessDeniedHandler" />
	</security:http>
	<security:http
		pattern="/parents/**"
		create-session="never"
		entry-point-ref="oauthAuthenticationEntryPoint"
		access-decision-manager-ref="accessDecisionManager"
		xmlns="http://www.springframework.org/schema/security">
		<security:anonymous enabled="false" />
		<security:intercept-url
			pattern="/parents/**"
			access="ROLE_APP" />
		<security:custom-filter
			ref="resourceServerFilter"
			before="PRE_AUTH_FILTER" />
		<security:access-denied-handler ref="oauthAccessDeniedHandler" />
	</security:http>
	<security:http
		pattern="/trainer/**"
		create-session="never"
		entry-point-ref="oauthAuthenticationEntryPoint"
		access-decision-manager-ref="accessDecisionManager"
		xmlns="http://www.springframework.org/schema/security">
		<security:anonymous enabled="false" />
		<security:intercept-url
			pattern="/trainer/**"
			access="ROLE_APP" />
		<security:custom-filter
			ref="resourceServerFilter"
			before="PRE_AUTH_FILTER" />
		<security:access-denied-handler ref="oauthAccessDeniedHandler" />
	</security:http>
	<security:http
		pattern="/club/**"
		create-session="never"
		entry-point-ref="oauthAuthenticationEntryPoint"
		access-decision-manager-ref="accessDecisionManager"
		xmlns="http://www.springframework.org/schema/security">
		<security:anonymous enabled="false" />
		<security:intercept-url
			pattern="/club/**"
			access="ROLE_APP" />
		<security:custom-filter
			ref="resourceServerFilter"
			before="PRE_AUTH_FILTER" />
		<security:access-denied-handler ref="oauthAccessDeniedHandler" />
	</security:http>
	<security:http
		pattern="/token/**"
		create-session="never"
		entry-point-ref="oauthAuthenticationEntryPoint"
		access-decision-manager-ref="accessDecisionManager">
		<security:anonymous enabled="false" />
		<security:intercept-url
			pattern="/token/**"
			access="ROLE_APP" />
		<security:custom-filter
			ref="resourceServerFilter"
			before="PRE_AUTH_FILTER" />
		<security:access-denied-handler ref="oauthAccessDeniedHandler" />
	</security:http>

	<bean 
		id="idegaEncoder" 
		class="com.idega.block.oauth2.server.configuration.IdegaPasswordEncoder"/>

	<bean 
		id="internalAuthenticationProvider" 
		class="com.idega.block.oauth2.server.configuration.InternalAuthenticationProvider"/>

	<!-- This is simple authentication manager, with a hardcoded user/password 
		combination. We can replace this with a user defined service to get few users 
		credentials from DB -->
	<security:authentication-manager
		alias="authenticationManager">
		<security:authentication-provider>
			<security:password-encoder
				ref="idegaEncoder"/>
			<security:jdbc-user-service 
				data-source-ref="dataSource"
				authorities-by-username-query="SELECT icl.user_login AS username, CASE WHEN icli.account_enabled = 'Y' THEN 'ROLE_APP' ELSE 'ROLE_APP' END AS authority FROM ic_login icl, ic_login_info icli where icli.ic_login_id = icl.ic_login_id and icl.user_login = ?"
				users-by-username-query="SELECT icl.user_login as username, icl.usr_password as password, CASE WHEN icli.account_enabled = 'Y' THEN 1 ELSE 0 END as enabled FROM ic_login icl, ic_login_info icli where icli.ic_login_id = icl.ic_login_id and icl.user_login = ?"
			/>
		</security:authentication-provider>
		<security:authentication-provider ref = "internalAuthenticationProvider">
		</security:authentication-provider>
	</security:authentication-manager>

	<!-- Global stuff -->

	<oauth:web-expression-handler id="oauthWebExpressionHandler" />
	<oauth:expression-handler id="oauthExpressionHandler" />

	<security:global-method-security
		pre-post-annotations="enabled"
		proxy-target-class="true">
		<!--you could also wire in the expression handler up at the layer of the 
			http filters. See https://jira.springsource.org/browse/SEC-1452 -->
		<security:expression-handler ref="oauthExpressionHandler" />
	</security:global-method-security>
</beans>  